今から感情を揺さぶる漫画LPの作成プロジェクトを行ってもらいます。

ユーザーからは漫画のテーマやストーリーの設定を画面に入力してもらいます。具体的には、主人公の設定、時代背景、業界や分野などの情報を入力してもらいます。

システム側の設定で、既に作成している漫画のパネルパターンの画像を各パターンごとに手元のPC内に設定しておいてもらいます。

具体例としては、1コマで主人公を大きく描くパネル、2コマで対比を表現するパネル、4コマでシーンを展開するパネル、セリフのみを強調するパネル、背景のみを描くパネルなど、各パネルのパターンをパターン化して、それに応じたパネルの参考画像を渡しておきます。

そして、その上で最初にユーザーに渡してもらったストーリー設定をGemini 3.0に渡して、そこでJSON形式で各パネルに表示させるセリフや内容などを分割して出力してもらいます。ストーリーは起承転結の構造を持ち、一度上がって一度下がり、また上がるような感情の起伏を描く必要があります。例えば、めちゃめちゃ貧乏で全然うまくいかなかった状況から、思想に出会い成功するもつまずく。それでもなんとか乗り越え、いい人生を手に入れる。しかし、そこでもう一度失敗する。その後また乗り越えていくような、挫折の後に希望が出てくるストーリーにしてください。

そのJSONの配列の中の一つのオブジェクトがパネル一枚一枚の中身になっています。

その配列の1要素の中身には、そのパネルで表示されるセリフやナレーション、そのパネルで使用する漫画のどの型（パターン）を使うのかという情報、パネルの感情的なトーン（希望、絶望、決意、安堵など）、追加のメタ情報を含めてください。それをGeminiで出力するようにしてください。

そしてこのJSONの最初から最後までをすべてパネルにするんですが、一つ目の要素をまずナノバナナでパネルの画像を生成した後、その2枚目のパネルを作成する際は、その一つ目で作成した画像を参照して、必ず整合性が取れるような形でパネルを作成してください。そのナノバナナに依頼する際は、表示するセリフやナレーションとともに、どのパネルの型を使って作成するのかを渡すので、その参考のパネルの型の画像も必ずセットで渡すようにしてください。なので合計2枚の画像を渡す形になります。
型の方は絶対に構成だけに参照するようにして、色味や雰囲気、キャラクターの見た目などは必ず他で生成された画像の雰囲気に合わせるようにしてください。

この処理をJSONの配列が終了するまで、最初から最後まで一つずつ処理を行ってください。

## 質問

ここまでの内容で漫画自体を作成できると思うのですが、何かそのシステムを構築する上で破綻している内容などがあるでしょうか。教えてください。

システムに詳しい自分であれば、かなり明確に何をしたらいいのか分かるんですが、これを一般的な人が使っても迷うことなく扱うことができ、ユーザーが何をしたらいいのか分からない、迷わないような見た目であったり、UI/UXの視点で考えてそこを漏れなく対応するようにしてください。なので、今どういう状況なのかっていうプログレスバーを出したり、ローディング中の表示であったり、次何をユーザーがしないといけないのかを明確にして、最初の開始の地点から終了地点までユーザーが全く迷うことなくこの漫画生成のアプリケーションを作れるようなUI/UXにしてください。

---

## 実装設計書（Next.js プロジェクト）

既存のプロジェクト構成（Next.js App Router, Tailwind CSS, TypeScript, Gemini API連携）を踏まえ、1ページで完結する漫画LP作成機能の実装設計を以下に定義します。

### 1. ディレクトリ・ファイル構成

新規に以下のファイルを作成・編集します。

- **ページコンポーネント**: `src/app/manga/page.tsx`
  - 漫画作成機能のメインページ。入力フォーム、プレビュー、生成フロー制御をすべてここで完結させます。
- **型定義**: `src/types/index.ts` (追記)
  - 漫画固有の型定義を追加します。
- **ロジック**: `src/lib/gemini.ts` (追記)
  - ストーリー構成生成用の関数を追加します。
- **定数/テンプレート**: `src/constants/manga-templates.ts` (新規)
  - コマ割りテンプレート（1コマ、2コマ、4コマなど）の定義とBase64/SVGデータを格納します。

### 2. データモデル設計 (`src/types/index.ts`)

```typescript
// 漫画のストーリー構成案
export interface MangaStoryPlan {
  title: string;
  theme: string;
  characters: {
    protagonist: string; // 主人公の設定
    style: string; // 画風・ビジュアルスタイル
  };
  panels: MangaPanelPlan[];
}

// 各パネル（コマ）の構成
export interface MangaPanelPlan {
  id: string;
  templateId: string; // 使用するコマ割りテンプレートID
  narrativePhase: "intro" | "rise" | "fall" | "climax" | "resolution"; // 起承転結のフェーズ
  description: string; // パネルの描画内容（プロンプトの元）
  dialogue: string; // セリフ
  narration: string; // ナレーション
  tone: string; // 感情的トーン（絶望、希望など）
  visualKeywords: string[]; // 生成用キーワード
}

// 生成結果の管理
export interface MangaPanelResult extends MangaPanelPlan {
  status: "pending" | "generating" | "done" | "error";
  imageUrl?: string;
  promptUsed?: string;
  error?: string;
}
```

### 3. バックエンドロジック設計 (`src/lib/gemini.ts`)

既存の `generateLpPlan` と同様に、`generateMangaStory` 関数を実装します。

- **プロンプト設計**:
  - ユーザー入力（主人公、設定、テーマ）を受け取り、JSON形式で `MangaStoryPlan` を出力させます。
  - **「感情のジェットコースター」**: プロンプト内で「貧乏→成功→挫折→再起→失敗→成功」という波のある展開を強制します。
  - **テンプレート指定**: 使用可能な `templateId` のリストを渡し、適切なコマ割りを選択させます。

```typescript
export async function generateMangaStory(
  userInput: string,
  templates: MangaTemplate[],
  apiKey: string
): Promise<MangaStoryPlan> {
  // ... Gemini API呼び出し実装 ...
}
```

### 4. 画像生成ロジックの拡張 (`src/lib/nanobanana.ts`)

既存の `generateImage` 関数を活用しますが、漫画生成特有のパラメータハンドリングを強化します。

- **参照画像 (Reference Image)**:
  - **テンプレート画像**: `layoutReferenceImage` として渡します。コマ割りの構成を守らせるためです。
  - **前のコマの画像**: `referenceImageBase64` として渡します。キャラクターの一貫性とストーリーの連続性を保つためです。
- **プロンプト拡張**:
  - 「前の画像の続きであること」「同じキャラクターであること」をプロンプトに追加します。
  - セリフは画像内に入れるのが難しいため、生成画像には**フキダシのみ**を描画させるか、あるいはテキストを含めないようにし、フロントエンド側で画像の上にテキストをオーバーレイ表示する形式を推奨します（多言語対応や修正の容易さのため）。**本要件では「画像内にセリフを含める指示」をプロンプトに入れますが、Geminiの画像生成能力に依存します。**

### 5. フロントエンド実装設計 (`src/app/manga/page.tsx`)

#### ステート管理

- `step`: 現在の工程 ("input" | "planning" | "generating" | "preview")
- `story`: 生成されたストーリー構成
- `panels`: 各パネルの生成状態管理（配列）
- `currentPanelIndex`: 生成中のパネルインデックス

#### UI構成

1.  **入力フェーズ**:
    - テキストエリア: 「どんな漫画にしますか？（例：昭和初期、貧乏な職人が世界一の技術を開発するが戦争ですべてを失う...）」
    - 設定オプション: 画風（劇画風、モダン、アメコミ風など）の選択。
2.  **構成確認フェーズ**:
    - Geminiが生成したストーリープロットとコマ割りをリスト表示。
    - ユーザーがセリフやトーンを修正可能にする。
3.  **生成フェーズ（自動実行）**:
    - **プログレスバー**: 全体の何枚目まで生成したかを可視化。
    - **リアルタイムプレビュー**: 生成が完了したコマから順次表示されていく（漫画が描かれていくような演出）。
    - **ローディング表示**: 現在生成中のコマを強調表示。
4.  **完了・プレビューフェーズ**:
    - 縦スクロールのLP形式で漫画を表示。
    - ダウンロードボタン（全画像を結合してダウンロード、または個別ダウンロード）。

#### ユーザー体験 (UX) の工夫

- **迷わせない**: ボタンは常に「次へ進む」の1つだけを強調。
- **フィードバック**: 「ストーリーを考案中...」「第3話を執筆中...」など、システム内部の動きを人間味のある言葉で表示。
- **リカバリー**: 生成に失敗したコマだけ「再生成」できるボタンを各コマに配置。

### 6. 実装ステップ

1.  **テンプレート準備**: `src/constants/manga-templates.ts` に代表的なコマ割りパターン（1コマ強調、2コマ会話、4コマ展開など）を定義。
2.  **Geminiロジック実装**: `src/lib/gemini.ts` にストーリー生成プロンプトと関数を実装。
3.  **UIスケルトン作成**: `src/app/manga/page.tsx` の基本レイアウト作成。
4.  **連携実装**: 入力→Gemini(構成)→確認→Gemini(画像生成ループ) のパイプラインを構築。
5.  **調整**: プロンプトのチューニング（特に一貫性の維持）。

この設計に基づき、実装を進めてください。
